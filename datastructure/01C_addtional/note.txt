
C语言中的变量：  int a = 7788; //就是在计算机系统中的内存里分配4字节空间， 用于存放7788值。存放这个值的内存单元的地址就变量a的地址.   

指针变量： 它是一种变量， 一般是用于存放其它变量的地址。它本身有地址。
	int a = 7788;
	int *p = &a;


	                       &p ==  [ &a  ]
			       &a ==  [ 7788]
二级指针变量： 也是一种变量，用于存放一级指针变量的地址
	int a = 5;
	int *p = &a; //指针变量p的值就是a的地址
	int **pp = &p; // pp的值是p的地址

	pp == &p;
	*pp == &a;
	**pp = a;

//////////////////////////////

函数指针变量:  void  (*func)(int , char *)   //声明一个无返回值，参数一个为int, 一个为char *的函数指针变量, 可用于存放同类型的函数的地址

void myfunc(int a, char *b)
{
	...
}	

函数名: myfunc就是函数的地址

	func = myfunc; //函数指针变量存放函数的地址
	func(参数，参数); //通过函数指针变量来调用函数
	
//////////
函数的参数是一个指针变量时，意味着调用此函数时需传递一个地址(可以是变量的地址，也可以是动态分配出来的空间地址)

函数的返回值类型一个指针变量时，意味着函数返回的是一个地址，我们需要用一个指针变量来存放返回的地址。

注意：所有类型的指针变量都需要指向一个有效的空间地址后才可以使用

/////////
程序： 编译出来的可执行文件镜像（还没有执行）， 如： a.out
进程： 处于执行状态的程序， 一个程序可以执行多次，产生多个进程


一个程序镜像里分有： xx段(section)
	分有很多个段， 通常我们要注意的有： 代码段(.text),  数据段(.data), 只读数据段(.rodata)
		                       未初始化的数据段(.bss)
反汇编： objdump -D  可执行文件 

编译过程：  C语言代码 ---> 汇编语句  ---> 机器码

段： 其实就是表示一个文件内的区域(从文件的第几个字节 ---到文件内的第几个字节结束）
代码段：用于存放需要执行的代码(编译完后是机器码，反汇编时，编译器会把机器码转为相应的汇编语句)

数据段： 存放初始化过全局变量， 初始化过的静态变量。 也就是这些变量在编译时编译器分配在这个区域里的。

未初始化数据段： 存放没初始化的全局变量， 没初始化的静态变量。 这些变量在编译时，不会分配具体的空间，只是在bss段里记录所需的空间。 在程序执行时，系统才会分配具体的空间。

只读数据段： 存放字符串常量， 只读全局变量(const).  这些变量在编译时，编译器会在这个区域里分配具体的空间
	char *p = "hello world";  //字符串"hello world"的内容存入只读数据段
		                  //至于指针p分配在哪个段与它的作用域有关

///////////////////////////////////////////////
局部变量的空间在代码执行时才会在栈里分配出来

栈(stack): 系统里用于分配局部变量的空间区域, 分配出来的空间地址是从高往低分配的.
	   系统里只有一个栈. 一个函数执行时，分从栈里分配局部变量的空间， 函数执行结束时会回收栈里分配的空间。回收的空间会重用的。
	   在系统里每个进程在栈里所使用的大小空间有限制(cenos7上不超过8M).
	   避免爆栈， 尽量使用动态分配空间

堆(heap) : 系统里用于动态分配空间的区域，分配出来的空间地址是从低往高分配的。
	   系统里只有一个堆。 每个进程在堆里使用的空间是没有限制大小， 只要系统还有可用内存即可申请成功。
	   动态分配出来的空间需要调用释放函数回收。
	   malloc()   ---  free()

//////////

结构体： 自定义一个数据类型

struct  human_t {
	int id;
	char name[20];
	int sex;
	int age;
};
     struct human_t 就是一个数据类型。

对象：(可以是一个变量， 也可以通过动态分配出来的变量)

算出结构体对象的成员对首地址的偏移： 用指针变量指向零地址，然后取成员的地址即是偏移量
根据结构体对象成员的地址得到首地址：  成员的地址减去偏移量


///////////////////////////

typedef struct node {
        int data;

        struct node *next;
        struct node *prev;
}node_t;

void func(int n)
{
	// n == 7788

	n = 9394;
}

int main(void)
{
	node_t *head = NULL;
	int num = 7788; //要在func函数里修改num变量的值
	func(7788);

	直接写head是取head指针变量存放的地址, 如要取指针变量的地址则： &head

	直接写指针变量就是取它所存放的地址

	如要在其它函数里需要修改一个变量的值时，则需把变量的地址传递过去

	如要在其它函数里修改一个指针变量的值(就是存放的地址)时，则需要把指针变量的地址传过去， 调用的函数的参数需用二级指针变量来存放传过来的指针变量的地址
}
	












































