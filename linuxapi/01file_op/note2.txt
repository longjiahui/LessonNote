1. access 用来检查文件是否存在和当前用户的操作权限
	int access(const char *pathname, int mode);
	返回值为0表示成功
	mode: F_OK, R_OK, W_OK, X_OK

   系统里的umask用于限制用户创建出来的文件的权限
   生成文件的权限: 用户指定的权限 &  (~umask)
2. umask 用来改变当前进程的umask
	创建文件时的权限  & (~umask)
	如： umake = 0022,  创建文件时提定的权限为0777
		则真正的权限为:  0777 & (~0022)  == 0755

   change mode
3. chmod  用改变文件的权限
   fchmod

   change owner
4. chown 用来修改文件的属主，所属的组
   int chown(const char *path, uid_t  owner,gid_t group); 


5. 
  硬链接: 相当于文件的一个备份.硬链接不能跨分区. 当删除一个文件时,就是把它的硬链接数减1, 
	当硬链接数为0时,表示这个文件已不会再使用,可以从硬盘上删除掉了. 
	 
  shell:	ln  源文件  新文件

  软链接: 相当于win系统上的快捷方式. 

  shell:        ln -s  源文件  快捷方式   


  系统函数:
   link 用来创建硬连接
   int  link(const  char *oldpath, const char *newpath);
	成功返回0， 失败返回－1

6. symlink 用来创建软连接
  int  symlink(const char *oldpath,  const char *newpath);

7. unlink 用来删除连接文件，当该文件的硬连接数为0时，则会把文件所占的硬盘空间空出来准备重用
  int unlink(const char *pathname);

8. remove 此函数删除文件时会调用unlink, 删除目录时会调用rmdir, rmdir只能删除空目录
	int remove(const char *pathname);

9. rename 相当shell的mv命令，但只能在同一个分区里 
	int rename(const char *oldpath, const char *newpath);

10. mkdir 创建目录,但不能同时创建多级不存在的目录
	int mkdir(const char *pathname, mode_t mode);
	mode指定创建出来的目录的权限

11. mount 挂载设备  // umount  
    int mount(const char *source, const char *target,             const char *filesystemtype, unsigned long mountflags,const void *data);
   int umount(const char *target);

12. chdir 设置当前的工作目录 
	int chdir(const char *path);
    getcwd 获取当前工作目录
	char *getcwd(char *buf, size_t size);
	buf指存放路径的buffer, size指buffer的长度

13. utime 改变文件的访问和修改时间
	int futimens(int fd, const struct timespec times[2]);
	int utime(const char *filename, const struct utimbuf *buf);
	utimebuf里的成员actime, modtime都是time_t类型,指从1970-1-1 00:00:00到现在差多少秒
	
	time_t mktime(struct tm *tm);
	此函数把tm类型的时间转换为time_t类型,tm里含有int类型的成员如年(从1900)，月(0-11)，日，时，分，秒等
	
//////////////////////////////
在linux目录也是个文件.
#include <dirent.h>
目录的操作函数:

14. opendir(3) 打开目录
 	#include <dirent.h>
        DIR *opendir(const char *name);

15. readdir(3) 从目录里读一项内容
	struct dirent *readdir(DIR *dir);
        struct dirent {
           ino_t  d_ino; /* inode number */
           off_t  d_off; /* offset to the next dirent */
           unsigned short d_reclen;/* length of this record */
           unsigned char  d_type;      /* type of file */
           char           d_name[256]; /* filename */
        };

17. 获取/设置当前进程的资源限制:
	#include <sys/resource.h>
       int getrlimit(int resource, struct rlimit *rlim);
       int setrlimit(int resource, const struct rlimit *rlim);	

    参数resource表示资源的种类:
      RLIMIT_AS: 可用虚拟内存的最大值
      RLIMIT_DATA: 数据段的最大值
      RLIMIT_NOFILE: 最大的文件描述符的数值

    参数rlim表示要设置的值：
　   struct rlimit {
       rlim_t rlim_cur;  /* Soft limit */
       rlim_t rlim_max;  /* Hard limit (ceiling for rlim_cur) */
    };


18. inotify //临控文件系统的事件  man 7 inotify
	#include <sys/inotify.h>

	1.int inotify_init(void) //初始化实例,得到一个文件描述符(ifd)
	2. int inotify_add_watch(int fd, const char  *pathname, uint32_t mask);  //增加一个监控的对象
	  fd 指的是初始化实例得来的文件描述符
	  pathname指的是文件或目录的路径名
	  mask 是指监控什么为行 IN_CREATE指创建, IN_DELETE指删除
	3. struct inotify_event evn;
	   read(ifd, &evn, sizeof(evn));
           struct inotify_event {
             int      wd;       /* Watch descriptor */
             uint32_t mask;     /* Mask of events */
             uint32_t cookie;   
             uint32_t len;      /* Size of ’name’ field */
             char     name[];   /* Optional null-terminated name */
         };


	
作业：1.mkdir -p    2. 继续完成ll查看目录 , 3.cp -r

